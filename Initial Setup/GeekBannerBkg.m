//
//  GeekBannerBkg.m
//  New Image
//
//  Created by John Basile on 11/15/12
//  Copyright 2012 John Basile
//  This code was generated by Opacity. You may use or modify it in any way.
//

#import "GeekBannerBkg.h"
#import <CoreText/CoreText.h>

@implementation BannerLayer
@synthesize geekTextLayer,titleTextLayer,footerTextLayer,dotLayer;
@synthesize bannerHeight,bannerWidth,comp0,comp1,comp2,title;

- (id)initWithFrame:(CGRect)frame
{
    self = [super init];
    if (self)
	{
        self.needsDisplayOnBoundsChange = YES;
    }
	self.bannerHeight = frame.size.height;
	self.bannerWidth = frame.size.width;
	self.bounds = frame;
	
	self.comp0 = 0;
	self.comp1 = 1;
	self.comp2 = 2;
	
	self.title = @"LOVE";
    return self;
}

- (id)init
{
    self = [super init];
    if (self)
	{
        self.needsDisplayOnBoundsChange = YES;
    }
    return self;
}

-(void)addTextLayers
{
	CTFontRef font = [self newCustomFontWithName:@"Bell MT"
										  ofType:@"otf"
									  attributes:[NSDictionary dictionaryWithObject:[NSNumber numberWithFloat:16.f]
																			 forKey:(NSString *)kCTFontSizeAttribute]];
	
	self.geekTextLayer = [[CATextLayer alloc] init];
	self.geekTextLayer.font = font;
	self.geekTextLayer.string = @"[Geek Logik]";
	self.geekTextLayer.shadowColor = [UIColor blackColor].CGColor;
	self.geekTextLayer.shadowOffset = CGSizeMake(2.0, 2.0);
    self.geekTextLayer.shadowOpacity = 1;
    self.geekTextLayer.shadowRadius = 2.0;
	self.geekTextLayer.wrapped = NO;
	self.geekTextLayer.foregroundColor = [[UIColor whiteColor] CGColor];
	self.geekTextLayer.fontSize = (bannerWidth > 700) ? 128.0 : 52.0;
	self.geekTextLayer.alignmentMode = kCAAlignmentCenter;
	self.geekTextLayer.frame = CGRectMake(0.0, (bannerWidth > 700) ? 48.0 : 28.0, bannerWidth, bannerHeight);
	[self addSublayer:self.geekTextLayer];
	
	
	self.titleTextLayer = [[CATextLayer alloc] init];
	self.titleTextLayer.font = font;
	self.titleTextLayer.string = self.title;
	self.titleTextLayer.wrapped = NO;
	self.titleTextLayer.foregroundColor = [[UIColor whiteColor] CGColor];
	self.titleTextLayer.fontSize = (bannerWidth > 700) ? 56.0 : 22.0;
	self.titleTextLayer.alignmentMode = kCAAlignmentCenter;
	self.titleTextLayer.frame = CGRectMake(0.0, (bannerWidth > 700) ? -10.0 :-4.0, bannerWidth, (bannerWidth > 700) ? 56.0 : 22.0);
	[self addSublayer:self.titleTextLayer];
	
	self.footerTextLayer = [[CATextLayer alloc] init];
	self.footerTextLayer.font = font;
	self.footerTextLayer.string = @"Foolproof Equations for Everyday Life";
	self.footerTextLayer.wrapped = NO;
	self.footerTextLayer.foregroundColor = [[UIColor whiteColor] CGColor];
	self.footerTextLayer.fontSize = (bannerWidth > 700) ? 30.0 : 14.0;
	self.footerTextLayer.alignmentMode = kCAAlignmentCenter;
	self.footerTextLayer.frame = CGRectMake(0.0, (bannerWidth > 700) ? 224.0 : 92.0, bannerWidth, (bannerWidth > 700) ? 40.0 : 16.0);
	[self addSublayer:self.footerTextLayer];
	
	CFRelease(font);
	
	self.dotLayer = [[GeekDot alloc]init];
	if(bannerWidth > 700)
	{
		self.dotLayer.bounds = CGRectMake(0., 0., 20, 20);
		self.dotLayer.position = CGPointMake(629.0, 86.0);
	}
	else
	{
		self.dotLayer.bounds = CGRectMake(0., 0., 10, 10);
		self.dotLayer.position = CGPointMake(260.0, 44.0);
	}
	[self addSublayer:self.dotLayer];
	[self applyFilter];
	
	[self.dotLayer setNeedsDisplay];
}

-(void)applyFilter
{
	[self.dotLayer setRasterizationScale:0.5];
	[self.dotLayer setShouldRasterize:YES];
	[self.dotLayer setNeedsDisplay];
}

-(void)setColor:(NSString *)color
{
	if( [color isEqualToString:@"Red"])
	{
		self.comp0 = 0;
		self.comp1 = 1;
		self.comp2 = 2;
	}
	else if( [color isEqualToString:@"Blue"])
	{
		self.comp0 = 2;
		self.comp1 = 0;
		self.comp2 = 1;
	}
	else if( [color isEqualToString:@"Green"])
	{
		self.comp0 = 1;
		self.comp1 = 0;
		self.comp2 = 2;
	}
}


- (CTFontRef)newCustomFontWithName:(NSString *)fontName ofType:(NSString *)type attributes:(NSDictionary *)attributes
{
	NSString *fontPath = [[NSBundle mainBundle] pathForResource:fontName ofType:type];
	
	NSData *data = [[NSData alloc] initWithContentsOfFile:fontPath];
	CGDataProviderRef fontProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);
	
	CGFontRef cgFont = CGFontCreateWithDataProvider(fontProvider);
	CGDataProviderRelease(fontProvider);
	
	CTFontDescriptorRef fontDescriptor = CTFontDescriptorCreateWithAttributes((__bridge CFDictionaryRef)attributes);
	CTFontRef font = CTFontCreateWithGraphicsFont(cgFont, 0, NULL, fontDescriptor);
	CFRelease(fontDescriptor);
	CGFontRelease(cgFont);
	return font;
}

- (void)drawInContext:(CGContextRef)context
{
    CGRect imageBounds = CGRectMake(0.0f, 0.0f, bannerWidth, bannerHeight);
    CGRect bounds = [self bounds];
    CGFloat alignStroke;
    CGFloat resolution;
    CGMutablePathRef path;
    CGRect drawRect;
    CGGradientRef gradient;
    CFMutableArrayRef colors;
    CGColorRef color;
    CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB();
    CGPoint point;
    CGPoint point2;
    CGAffineTransform transform;
    CGFloat components[4];
    CGFloat locations[3];
    
    transform = CGContextGetUserSpaceToDeviceSpaceTransform(context);
    resolution = sqrtf(fabsf(transform.a * transform.d - transform.b * transform.c)) * 0.5f * (bounds.size.width / imageBounds.size.width + bounds.size.height / imageBounds.size.height);
    
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, bounds.origin.x, bounds.origin.y);
    CGContextScaleCTM(context, (bounds.size.width / imageBounds.size.width), (bounds.size.height / imageBounds.size.height));
    
    // Layer 1
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(0.0f, 0.0f, bannerWidth, bannerHeight);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddRect(path, NULL, drawRect);
    colors = CFArrayCreateMutable(NULL, 3, &kCFTypeArrayCallBacks);
    components[0] = 0.104f;
    components[1] = 0.104f;
    components[2] = 0.104f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.0f;
    components[0] = 0.101f;
    components[1] = 0.101f;
    components[2] = 0.101f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 1.0f;
    components[self.comp0] = 0.208f;
    components[self.comp1] = 0.0f;
    components[self.comp2] = 0.031f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[2] = 0.495f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    point = CGPointMake(0.0f, 0.5*bannerWidth);
    point2 = CGPointMake(bannerWidth, 0.5*bannerWidth);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    // Top Banner
    
	float sbHeight = (bannerWidth > 700) ? 48.0 : 20.0;
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(0.0f, 0.0f, bannerWidth, sbHeight);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddRect(path, NULL, drawRect);
    colors = CFArrayCreateMutable(NULL, 3, &kCFTypeArrayCallBacks);
    components[self.comp0] = 0.067f;
    components[self.comp1] = 0.02f;
    components[self.comp2] = 0.02f;
    components[3] = 0.92f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.0f;
    components[self.comp0] = 0.067f;
    components[self.comp1] = 0.02f;
    components[self.comp2] = 0.02f;
    components[3] = 0.8f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 1.0f;
    components[self.comp0] = 0.565f;
    components[self.comp1] = 0.0f;
    components[self.comp2] = 0.031f;
    components[3] = 0.91f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[2] = 0.513f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    point  = CGPointMake(  0.0f, 0.5*sbHeight);
    point2 = CGPointMake(bannerWidth, 0.5*sbHeight);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    CGContextRestoreGState(context);
    CGColorSpaceRelease(space);
}

@end
