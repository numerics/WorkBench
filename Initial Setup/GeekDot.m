//
//  GeekDot.m
//  New Image
//
//  Created by John Basile on 11/23/12
//  Copyright 2012 John Basile
//  This code was generated by Opacity. You may use or modify it in any way.
//

#import "GeekDot.h"

const CGFloat kGeekDotWidth = 16.0;
const CGFloat kGeekDotHeight = 16.0;

@implementation GeekDot


- (id)init
{
    self = [super init];
    if (self)
	{
        self.needsDisplayOnBoundsChange = YES;
    }
    return self;
}

- (void)drawInContext:(CGContextRef)context
{
    CGRect imageBounds = CGRectMake(0.0f, 0.0f, kGeekDotWidth, kGeekDotHeight);
    CGRect bounds = [self bounds];
    CGFloat alignStroke;
    CGFloat resolution;
    CGMutablePathRef path;
    CGRect drawRect;
    CGGradientRef gradient;
    CFMutableArrayRef colors;
    CGColorRef color;
    CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB();
    CGAffineTransform transform;
    CGRect pathBounds;
    CGFloat components[4];
    CGFloat locations[2];
    
    transform = CGContextGetUserSpaceToDeviceSpaceTransform(context);
    resolution = sqrtf(fabsf(transform.a * transform.d - transform.b * transform.c)) * 0.5f * (bounds.size.width / imageBounds.size.width + bounds.size.height / imageBounds.size.height);
    
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, bounds.origin.x, bounds.origin.y);
    CGContextScaleCTM(context, (bounds.size.width / imageBounds.size.width), (bounds.size.height / imageBounds.size.height));
    
    // Layer 1
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(0.0, 0.0, kGeekDotWidth, kGeekDotHeight);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddEllipseInRect(path, NULL, drawRect);
    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
    components[0] = 1.0f;
    components[1] = 0.271f;
    components[2] = 0.318f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.0f;
    components[0] = 0.849f;
    components[1] = 0.004f;
    components[2] = 0.013f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    pathBounds = CGPathGetPathBoundingBox(path);
    transform = CGAffineTransformMakeTranslation(CGRectGetMidX(pathBounds), CGRectGetMidY(pathBounds));
    transform = CGAffineTransformScale(transform, 0.5f * pathBounds.size.width, 0.5f * pathBounds.size.height);
    CGContextConcatCTM(context, transform);
    CGContextDrawRadialGradient(context, gradient, CGPointZero, 1.0f, CGPointMake(0.0f, 0.0f), 0.0f, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    CGContextRestoreGState(context);
    CGColorSpaceRelease(space);
}

@end
